<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Site Calibration Pro</title>
    <meta name="description" content="Offline Site Calibration Tool">
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.58.1/build/stlite.css">
    <link rel="icon" type="image/png" href="icon.png">
    <style>
        /* Splash screen styles */
        .stlite-loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: sans-serif;
            background-color: #0e1117;
            color: white;
        }
    </style>
</head>

<body>
    <div id="root">
        <div class="stlite-loader">
            <img src="icon.png" width="80" height="80" alt="Loading">
            <p>Cargando Motor de Calibraci√≥n...</p>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.58.1/build/stlite.js"></script>
    <script>
        stlite.mount({
            requirements: ["pandas", "numpy", "matplotlib", "pyproj", "tabulate", "pytz", "altair"],
            entrypoint: "app.py",
            files: {
                "sitecal/__init__.py": "",
                "sitecal/core/__init__.py": "",
                "sitecal/infrastructure/__init__.py": "",
                "app.py": `
import streamlit as st
import pandas as pd
import io
import numpy as np
import altair as alt

# Core Imports for Offline Processing
from sitecal.core.calibration_engine import Similarity2D
from sitecal.core.projections import ProjectionFactory
from sitecal.infrastructure.reports import generate_markdown_report

def validate_collinearity(df: pd.DataFrame) -> bool:
    """Checks for collinearity in points."""
    if "Easting_global" not in df.columns or "Northing_global" not in df.columns:
        return False
    coords = df[["Easting_global", "Northing_global"]].values
    if len(coords) < 3: return False
    centered = coords - np.mean(coords, axis=0)
    cov = np.cov(centered, rowvar=False)
    eigvals = np.linalg.eigvals(cov)
    if np.max(eigvals) == 0: return True
    return (np.min(eigvals) / np.max(eigvals)) < 1e-4

def main():
    st.set_page_config(page_title="Site Calibration (Offline)", page_icon="üõ∞Ô∏è", layout="wide")
    
    st.title("Site Calibration Tool (Monolith)")
    st.markdown("C√°lculo local y seguro. No requiere conexi√≥n a internet.")

    # Instructions
    with st.expander("‚ÑπÔ∏è Instrucciones de Formato CSV (Importante)"):
        st.markdown("""
        ### Archivo Global (GNSS)
        **Formato:** Coordenadas Geod√©sicas WGS84 (Grados Decimales)
        * **Columnas Requeridas:** \`Point\` (ID), \`Latitude\`, \`Longitude\`, \`Ellipsoidal Height\` (o \`h\`)
        * **Precisi√≥n:** Al menos **8 decimales** en Lat/Lon para asegurar precisi√≥n milim√©trica.

        ### Archivo Local (Planas)
        **Formato:** Coordenadas Cartesianas Locales (Metros)
        * **Columnas Requeridas:** \`Point\` (ID), \`Easting\` (Este), \`Northing\` (Norte), \`Elevation\` (o \`z\`, \`h\`)
        """)
        
    # Main Input Section
    col1, col2 = st.columns(2)
    
    global_df = None
    local_df = None
    
    with col1:
        st.subheader("Coordenadas Globales (CSV)")
        global_file = st.file_uploader("Subir CSV Global", type=["csv"], key="global")
        if global_file:
            has_header_g = st.checkbox("Tiene encabezados", value=True, key="header_g")
            global_df = pd.read_csv(global_file, header=0 if has_header_g else None)
            st.dataframe(global_df.head(), use_container_width=True)
            
            st.markdown("##### Mapeo de Columnas")
            cols_g = global_df.columns.tolist()
            g_point = st.selectbox("Point (ID)", cols_g, index=0 if cols_g else 0, key="g_pt")
            g_lat = st.selectbox("Latitude", cols_g, index=1 if len(cols_g)>1 else 0, key="g_lat")
            g_lon = st.selectbox("Longitude", cols_g, index=2 if len(cols_g)>2 else 0, key="g_lon")
            g_h = st.selectbox("Ellipsoidal Height", cols_g, index=3 if len(cols_g)>3 else 0, key="g_h")
        
    with col2:
        st.subheader("Coordenadas Locales (CSV)")
        local_file = st.file_uploader("Subir CSV Local", type=["csv"], key="local")
        if local_file:
            has_header_l = st.checkbox("Tiene encabezados", value=True, key="header_l")
            local_df = pd.read_csv(local_file, header=0 if has_header_l else None)
            st.dataframe(local_df.head(), use_container_width=True)

            st.markdown("##### Mapeo de Columnas")
            cols_l = local_df.columns.tolist()
            l_point = st.selectbox("Point (ID)", cols_l, index=0 if cols_l else 0, key="l_pt")
            l_e = st.selectbox("Easting", cols_l, index=1 if len(cols_l)>1 else 0, key="l_e")
            l_n = st.selectbox("Northing", cols_l, index=2 if len(cols_l)>2 else 0, key="l_n")
            l_z = st.selectbox("Elevation", cols_l, index=3 if len(cols_l)>3 else 0, key="l_z")
            
            # Helper Visualization
            st.markdown("##### Geometr√≠a Local")
            try:
                # Use Altair for precise control over axes (no zero inclusion)
                chart_data = local_df.rename(columns={l_point: "Point", l_e: "Easting", l_n: "Northing"})
                
                c = alt.Chart(chart_data).mark_circle(size=60, color="#FF4B4B").encode(
                    x=alt.X("Easting", scale=alt.Scale(zero=False), title="Easting (m)"),
                    y=alt.Y("Northing", scale=alt.Scale(zero=False), title="Northing (m)"),
                    tooltip=["Point", "Easting", "Northing"]
                ).interactive()

                st.altair_chart(c, use_container_width=True)
            except Exception:
                st.caption("No se pudo generar la previsualizaci√≥n gr√°fica. Verifique el mapeo de columnas.")

    # Method Selection and Parameters
    st.subheader("M√©todo y Par√°metros")
    col_method, col_params = st.columns([1, 3])
    
    with col_method:
        method = st.selectbox("Seleccionar M√©todo", ["Default", "LTM"])
    
    params = {}
    if method == "LTM":
        with col_params:
            c1, c2, c3, c4 = st.columns(4)
            with c1: params["central_meridian"] = st.number_input("Meridiano Central", value=-72.0)
            with c2: params["scale_factor"] = st.number_input("Factor de Escala", value=0.9996, format="%.6f")
            with c3: params["false_easting"] = st.number_input("Falso Este", value=500000.0)
            with c4: params["false_northing"] = st.number_input("Falso Norte", value=10000000.0)

    # Action
    st.markdown("---")
    if st.button("Calcular Calibraci√≥n (Offline)", type="primary", use_container_width=True):
        if global_df is None or local_df is None:
            st.error("Por favor sube ambos archivos CSV (Global y Local).")
            return

        with st.spinner("Procesando localmente..."):
            try:
                # 1. Standardize Inputs
                df_g_ready = global_df.rename(columns={
                    g_point: "Point", g_lat: "Latitude", g_lon: "Longitude", g_h: "EllipsoidalHeight"
                })[["Point", "Latitude", "Longitude", "EllipsoidalHeight"]]
                df_g_ready["Point"] = df_g_ready["Point"].astype(str)

                df_l_ready = local_df.rename(columns={
                    l_point: "Point", l_e: "Easting", l_n: "Northing", l_z: "Elevation"
                })[["Point", "Easting", "Northing", "Elevation"]]
                df_l_ready["Point"] = df_l_ready["Point"].astype(str)

                # 2. Projection
                proj_params = {k: v for k, v in params.items()}
                projection = ProjectionFactory.create(method.lower(), **proj_params)
                df_g_proj = projection.project(df_g_ready)

                # 3. Merge
                merged_df = pd.merge(df_l_ready, df_g_proj, on="Point", suffixes=('_local', '_global'))
                if len(merged_df) < 3:
                    st.error(f"Error: Solo se encontraron {len(merged_df)} puntos comunes. Se requieren m√≠nimo 3.")
                    return
                
                if validate_collinearity(merged_df):
                    st.error("Error: Los puntos son colineales o geogr√°ficamente muy cercanos. Geometr√≠a inestable.")
                    return

                # 4. Calibration Engine
                engine = Similarity2D()
                engine.train(df_l_ready, df_g_proj)

                # 5. Build Result Object
                residuals = [
                    {"Point": str(row["Point"]), "dE": float(row["dE"]), "dN": float(row["dN"]), "dH": float(row["dH"])}
                    for _, row in engine.residuals.iterrows()
                ]
                
                report_text = generate_markdown_report(engine, "not_used", method.lower())
                
                result_data = {
                    "parameters": {
                        "horizontal": engine.horizontal_params,
                        "vertical": engine.vertical_params
                    },
                    "residuals": residuals,
                    "report": report_text
                }
                
                display_results(result_data)

            except Exception as e:
                st.error(f"Error Interno: {str(e)}")

def display_results(data):
    # 1. Calculated Parameters (Visual)
    if "parameters" in data:
        p = data["parameters"]
        
        if "horizontal" in p and p["horizontal"]:
             st.subheader("üèóÔ∏è Ajuste Horizontal (2D)")
             hp = p["horizontal"]
             c1, c2, c3, c4 = st.columns(4)
             with c1: st.metric("Factor Escala (a)", f"{hp['a']:.7f}")
             with c2: st.metric("Rotaci√≥n (b)", f"{hp['b']:.7f}")
             with c3: st.metric("Traslasi√≥n Este", f"{hp['tE']:.3f} m")
             with c4: st.metric("Traslasi√≥n Norte", f"{hp['tN']:.3f} m")
             
        if "vertical" in p and p["vertical"]:
             st.subheader("üìê Ajuste Vertical (1D)")
             vp = p["vertical"]
             c1, c2, c3, c4 = st.columns(4)
             with c1: st.metric("Shift Vertical", f"{vp['vertical_shift']:.3f} m")
             with c2: st.metric("Inclinaci√≥n N", f"{vp['slope_north']*1e6:.2f} ppm")
             with c3: st.metric("Inclinaci√≥n E", f"{vp['slope_east']*1e6:.2f} ppm")
             with c4: st.metric("Centroide", f"({vp['centroid_north']:.0f}, {vp['centroid_east']:.0f})")

        st.markdown("---")

    # 2. Residuals Table (Interactive)
    if "residuals" in data:
        st.subheader("Cuadr√≠cula de Residuales")
        residuals = data["residuals"]
        if isinstance(residuals, list) and len(residuals) > 0:
             df = pd.DataFrame(residuals)
             df.rename(columns={"dE": "dE (m)", "dN": "dN (m)", "dH": "dH (m)"}, inplace=True)
             st.dataframe(df, use_container_width=True)
        else:
            st.info("No se devolvieron datos de residuales.")
        st.markdown("---")

    # 3. Full Report (Hidden in Expander to avoid redundancy)
    if "report" in data:
        with st.expander("üìÑ Ver/Copiar Reporte Completo (Markdown)"):
            st.markdown("Este reporte contiene la misma informaci√≥n de arriba pero en formato texto para copiar y pegar.")
            st.code(data["report"], language="markdown")
            st.markdown("---")
            st.markdown(data["report"])

if __name__ == "__main__":
    main()
`,
                "sitecal/core/calibration_engine.py": `
from abc import ABC, abstractmethod
import numpy as np
import pandas as pd


class Calibration(ABC):
    @abstractmethod
    def train(self, df_local: pd.DataFrame, df_global: pd.DataFrame):
        pass

    @abstractmethod
    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        pass


class Similarity2D(Calibration):
    def __init__(self):
        self.horizontal_params = None
        self.vertical_params = None
        self.residuals = None

    def train(self, df_local: pd.DataFrame, df_global: pd.DataFrame):
        """
        Calculates 2D similarity transformation parameters (a, b, tE, tN)
        and Vertical Adjustment parameters (Inclined Plane or Constant Shift).
        """
        
        merged_df = pd.merge(df_local, df_global, on="Point", suffixes=('_local', '_global'))
        n = len(merged_df)

        # --- Horizontal (2D Similarity) ---
        x = merged_df["Easting_global"].values
        y = merged_df["Northing_global"].values
        E = merged_df["Easting_local"].values
        N = merged_df["Northing_local"].values
        
        # Calculate centroids
        x_c = np.mean(x)
        y_c = np.mean(y)
        E_c = np.mean(E)
        N_c = np.mean(N)
        
        # Center coordinates
        x_prime = x - x_c
        y_prime = y - y_c
        E_prime = E - E_c
        N_prime = N - N_c

        # Solve for a and b using centered coordinates
        A = np.zeros((2 * n, 2))
        A[:n, 0] = x_prime
        A[:n, 1] = -y_prime
        A[n:, 0] = y_prime
        A[n:, 1] = x_prime

        L = np.concatenate([E_prime, N_prime])

        params_ab, _, _, _ = np.linalg.lstsq(A, L, rcond=None)
        a = params_ab[0]
        b = params_ab[1]
        
        # Calculate translations
        tE = E_c - a * x_c + b * y_c
        tN = N_c - b * x_c - a * y_c

        self.horizontal_params = {"a": a, "b": b, "tE": tE, "tN": tN}

        # --- Vertical (Inclined Plane) ---
        # Z_error = Z_global - Z_local
        # Model: Z_error = C + S_N * (N_local - N_c) + S_E * (E_local - E_c)
        
        # Get heights. Strict Schema.
        h_global = merged_df["EllipsoidalHeight"].values 
        h_local = merged_df["Elevation"].values
        
        Z_error = h_global - h_local
        
        if n >= 3:
            # Planar fit
            # A matrix: [1, (N - N_c), (E - E_c)]
            # We use local coordinates for the domain of the inclination as per standard practice (or translated global)
            # TBC usually applies inclination based on position. Let's use Local Centering.
            
            A_v = np.ones((n, 3))
            A_v[:, 1] = N_prime # Using N_prime (N_local - N_c) is a good approximation for centering
            A_v[:, 2] = E_prime
            
            # Solve for [C, S_N, S_E]
            v_params, _, _, _ = np.linalg.lstsq(A_v, Z_error, rcond=None)
            C = v_params[0]
            slope_n = v_params[1]
            slope_e = v_params[2]
        else:
            # Constant shift only
            C = np.mean(Z_error)
            slope_n = 0.0
            slope_e = 0.0
            
        self.vertical_params = {
            "vertical_shift": C,
            "slope_north": slope_n,
            "slope_east": slope_e,
            "centroid_north": N_c,
            "centroid_east": E_c
        }
        
        # Calculate residuals & Transformed Values
        transformed = self.transform(merged_df)
        self.residuals = pd.DataFrame({
            "Point": merged_df["Point"],
            "dE": transformed["Easting"] - merged_df["Easting_local"],
            "dN": transformed["Northing"] - merged_df["Northing_local"],
            "dH": transformed["h"] - merged_df.get("Elevation", 0) - (merged_df.get("EllipsoidalHeight", 0) - merged_df.get("Elevation", 0)) 
        })
        # dH = Transformed (Local Calc) - Expected Local (Elevation)
        # Transformed["h"] is the calculated Local Height.
        # So dH = Transformed["h"] - Elevation
        self.residuals["dH"] = transformed["h"] - merged_df["Elevation"]


    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        if self.horizontal_params is None or self.vertical_params is None:
            raise RuntimeError("The calibration model has not been trained.")
        
        # Horizontal
        a = self.horizontal_params["a"]
        b = self.horizontal_params["b"]
        tE = self.horizontal_params["tE"]
        tN = self.horizontal_params["tN"]

        # Vertical
        C = self.vertical_params["vertical_shift"]
        Sn = self.vertical_params["slope_north"]
        Se = self.vertical_params["slope_east"]
        Nc = self.vertical_params["centroid_north"]
        Ec = self.vertical_params["centroid_east"]

        # Handle column names dynamically
        if "Easting_global" in df.columns:
            x = df["Easting_global"].values
            y = df["Northing_global"].values
        else:
            x = df["Easting"].values
            y = df["Northing"].values
            
        # Vertical Height Selection (Global First)
        if "EllipsoidalHeight" in df.columns:
             h_input = df["EllipsoidalHeight"].values
        elif "Elevation" in df.columns:
             # Fallback for purely local ops (uncommon in strict transformations)
             h_input = df["Elevation"].values
        else:
             h_input = np.zeros(len(df))

        # Apply 2D Sim
        E_trans = a * x - b * y + tE
        N_trans = b * x + a * y + tN
        
        # Apply Vertical Adjustment
        # We need N_local and E_local for the plane. 
        # If we only have global input (transforming global to local), we use the transformed values as proxy for position
        # Or if we have local columns in input.
        
        # The plane Z_err = C + Sn*(N - Nc) + Se*(E - Ec)
        # Z_local_derived = Z_global - Z_err (if subtracting error) or Z_local + Z_adj = Z_global
        # Let's align with the training: Z_error = Z_global - Z_local
        # So Z_global = Z_local + Z_error
        
        dZ = C + Sn * (N_trans - Nc) + Se * (E_trans - Ec)
        
        H_trans = h_input - dZ
        
        return pd.DataFrame({
            "Point": df["Point"],
            "Easting": E_trans,
            "Northing": N_trans,
            "h": H_trans
        })



class CalibrationFactory:
    @staticmethod
    def create(method: str) -> Calibration:
        if method == "tbc" or method == "ltm":
            return Similarity2D()
        else:
            raise ValueError(f"Unknown calibration method: {method}")
`,
                "sitecal/core/projections.py": `
from abc import ABC, abstractmethod
import numpy as np
import pandas as pd
from pyproj import CRS, Transformer
from pyproj.exceptions import ProjError


class Projection(ABC):
    @abstractmethod
    def project(self, df: pd.DataFrame) -> pd.DataFrame:
        pass


class Default(Projection):
    def project(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Uses the first point as the origin (0,0) and a scale factor of 1.
        This creates a local Transverse Mercator projection centered on the project.
        """
        if df.empty:
            raise ValueError("Cannot project empty DataFrame. Need at least one point to define origin.")

        # Use the first point as the projection origin
        lat_0 = df.iloc[0]["Latitude"]
        lon_0 = df.iloc[0]["Longitude"]
        
        # Define projection: TM, Origin at 1st point, Scale 1.0, FE 0, FN 0
        proj_string = (
            f"+proj=tmerc +lat_0={lat_0} +lon_0={lon_0} "
            f"+k=1.0 +x_0=0 +y_0=0 "
            f"+ellps=WGS84 +datum=WGS84 +units=m +no_defs"
        )
        
        src_crs = CRS("EPSG:4326")  # WGS84 Geodetic
        dst_crs = CRS(proj_string)

        transformer = Transformer.from_crs(src_crs, dst_crs, always_xy=True)

        try:
            # Transform all points to this local system
            easting, northing = transformer.transform(df["Longitude"].values, df["Latitude"].values)
            
            df_out = df.copy()
            df_out["Easting"] = easting
            df_out["Northing"] = northing
            return df_out
            
        except ProjError as e:
            raise RuntimeError(f"Default Projection failed: {e}")


class UTM(Projection):
    def project(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Projects geodetic coordinates (Lat, Lon) to UTM.
        The UTM zone is automatically determined from the mean longitude.
        """
        if df.empty:
             raise ValueError("Cannot project empty DataFrame")

        lon_mean = df["Longitude"].mean()
        # Simple UTM zone calculation
        utm_zone = int((lon_mean + 180) / 6) + 1
        
        src_crs = CRS("EPSG:4326")  # WGS84
        # Assuming southern hemisphere for Chile/South America focus, 
        # but technically should check Lat. keeping simple for MVP.
        is_south = df["Latitude"].mean() < 0
        epsg_code = 32700 + utm_zone if is_south else 32600 + utm_zone
        
        dst_crs = CRS(f"EPSG:{epsg_code}")

        transformer = Transformer.from_crs(src_crs, dst_crs, always_xy=True)

        try:
            easting, northing = transformer.transform(df["Longitude"].values, df["Latitude"].values)
            df_out = df.copy()
            df_out["Easting"] = easting
            df_out["Northing"] = northing
            return df_out
        except ProjError as e:
            raise RuntimeError(f"UTM Projection failed: {e}")


class LTM(Projection):
    def __init__(self, central_meridian, latitude_of_origin, false_easting, false_northing, scale_factor):
        self.central_meridian = central_meridian
        self.latitude_of_origin = latitude_of_origin
        self.false_easting = false_easting
        self.false_northing = false_northing
        self.scale_factor = scale_factor

    def project(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Projects geodetic coordinates to a custom LTM projection.
        """
        if df.empty:
             raise ValueError("Cannot project empty DataFrame")

        proj_string = (
            f"+proj=tmerc +lat_0={self.latitude_of_origin} +lon_0={self.central_meridian} "
            f"+k={self.scale_factor} +x_0={self.false_easting} +y_0={self.false_northing} "
            f"+ellps=WGS84 +datum=WGS84 +units=m +no_defs"
        )
        
        src_crs = CRS("EPSG:4326")  # WGS84
        dst_crs = CRS(proj_string)

        transformer = Transformer.from_crs(src_crs, dst_crs, always_xy=True)
        
        try:
            easting, northing = transformer.transform(df["Longitude"].values, df["Latitude"].values)
            df_out = df.copy()
            df_out["Easting"] = easting
            df_out["Northing"] = northing
            return df_out
        except ProjError as e:
            raise RuntimeError(f"LTM Projection failed: {e}")


class ProjectionFactory:
    @staticmethod
    def create(method: str, **kwargs) -> Projection:
        if method == "default":
            return Default()
        elif method == "utm":
            return UTM()
        elif method == "ltm":
            return LTM(
                central_meridian=kwargs.get("central_meridian"),
                latitude_of_origin=kwargs.get("latitude_of_origin"),
                false_easting=kwargs.get("false_easting"),
                false_northing=kwargs.get("false_northing"),
                scale_factor=kwargs.get("scale_factor"),
            )
        else:
            raise ValueError(f"Unknown projection method: {method}")
`,
                "sitecal/infrastructure/reports.py": `
import pandas as pd
from sitecal.core.calibration_engine import Calibration
import datetime
import pytz

def generate_markdown_report(
    calibration: Calibration,
    output_path: str,
    method: str
):
    """
    Generates a Markdown report with calibration results.
    """
    
    report_lines = []
    
    now = datetime.datetime.now(pytz.timezone('America/Santiago')).strftime("%Y-%m-%d %H:%M:%S")
    
    report_lines.append("# Site Calibration Report")
    report_lines.append("")
    report_lines.append(f"Report generated on: {now}")
    report_lines.append("")
    report_lines.append(f"## Calibration Method: {method.upper()}")
    report_lines.append("")

    # Horizontal Transformation Parameters (2D)
    report_lines.append("### üèóÔ∏è Ajuste Horizontal (2D)")
    report_lines.append("")
    if calibration.horizontal_params:
        hp = calibration.horizontal_params
        report_lines.append("- **Factor de Escala (a):** " + f"\`{hp['a']:.6f}\`")
        report_lines.append("- **T√©rmino de Rotaci√≥n (b):** " + f"\`{hp['b']:.6f}\`")
        report_lines.append("- **Traslaci√≥n Este:** " + f"\`{hp['tE']:.3f} m\`")
        report_lines.append("- **Traslaci√≥n Norte:** " + f"\`{hp['tN']:.3f} m\`")
        
        # Derived: Scale and Rotation
        scale = (hp['a']**2 + hp['b']**2)**0.5
        import math
        rotation_rad = math.atan2(hp['b'], hp['a'])
        rotation_deg = math.degrees(rotation_rad)
        rotation_dms_d = int(rotation_deg)
        rotation_dms_m = int((abs(rotation_deg) - abs(rotation_dms_d)) * 60)
        rotation_dms_s = (abs(rotation_deg) - abs(rotation_dms_d) - rotation_dms_m/60) * 3600
        
        report_lines.append(f"- **Escala Impl√≠cita:** \`{scale:.8f}\`")
        report_lines.append(f"- **Rotaci√≥n Impl√≠cita:** \`{rotation_dms_d}¬∞ {rotation_dms_m}' {rotation_dms_s:.1f}\\\"\`")

    else:
        report_lines.append("No se calcularon par√°metros horizontales.")
    report_lines.append("")
    
    # Vertical Adjustment Parameters (Inclined Plane)
    report_lines.append("### üìê Ajuste Vertical (1D)")
    report_lines.append("")
    if calibration.vertical_params:
        vp = calibration.vertical_params
        report_lines.append(f"- **Desplazamiento Vertical (Shift):** \`{vp['vertical_shift']:.3f} m\`")
        report_lines.append(f"- **Inclinaci√≥n Norte:** \`{vp['slope_north']*1e6:.2f} ppm\`")
        report_lines.append(f"- **Inclinaci√≥n Este:** \`{vp['slope_east']*1e6:.2f} ppm\`")
        report_lines.append(f"- **Centroide (N, E):** \`({vp['centroid_north']:.3f}, {vp['centroid_east']:.3f})\`")
    else:
        report_lines.append("No se calcularon par√°metros verticales.")
    report_lines.append("")

    # Residuals Table
    report_lines.append("### Residuals (mm)")
    report_lines.append("")
    if calibration.residuals is not None:
        residuals_mm = calibration.residuals.copy()
        residuals_mm["dE"] = (residuals_mm["dE"] * 1000).round(1)
        residuals_mm["dN"] = (residuals_mm["dN"] * 1000).round(1)
        residuals_mm["dH"] = (residuals_mm["dH"] * 1000).round(1)
        residuals_mm.rename(columns={"dE": "dE (mm)", "dN": "dN (mm)", "dH": "dH (mm)"}, inplace=True)
        report_lines.append(residuals_mm.to_markdown(index=False))
    else:
        report_lines.append("No residuals were calculated.")
    report_lines.append("")

    # Statistics
    report_lines.append("### Statistics")
    report_lines.append("")
    if calibration.residuals is not None:
        residuals = calibration.residuals
        # Calculate horizontal error
        residuals["error_h"] = (residuals["dE"]**2 + residuals["dN"]**2)**0.5
        
        worst_point = residuals.loc[residuals["error_h"].idxmax()]
        best_point = residuals.loc[residuals["error_h"].idxmin()]
        std_dev = residuals[["dE", "dN", "dH"]].std().to_dict()
        percentile_99 = residuals["error_h"].quantile(0.99)

        report_lines.append(f"- **Worst Point:** \`{worst_point['Point']}\` (Error: {(worst_point['error_h'] * 1000):.1f} mm)")
        report_lines.append(f"- **Best Point:** \`{best_point['Point']}\` (Error: {(best_point['error_h'] * 1000):.1f} mm)")
        report_lines.append("- **Standard Deviations (mm):**")
        for axis, value in std_dev.items():
            report_lines.append(f"  - \`{axis}\`: {(value * 1000):.1f} mm")
        report_lines.append(f"- **99th Percentile of Horizontal Errors:** {(percentile_99 * 1000):.1f} mm")

    else:
        report_lines.append("Statistics could not be calculated.")
    report_lines.append("")

    return "\\n".join(report_lines) + "\\n"
`
            }
        }, document.getElementById("root"))
    </script>
</body>

</html>